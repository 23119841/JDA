#ifndef CASCADOR_HPP_
#define CASCADOR_HPP_

#include <vector>

namespace jda {

// pre-define
class BoostCart;

/**
 * JoinCascador for face classification and landmark regression
 */
class JoinCascador {
public:
    JoinCascador();
    ~JoinCascador();
    /**
     * Initialize JionCascador
     * :input T:    stages, should be `Config::T`
     */
    void Initialize(int T);

public:
    /**
     * Train JoinCascador
     *
     * See Full Algorithm on paper `Algorithm 3`
     */
    void Train(DataSet& pos, DataSet& neg);
    /**
     * Snapshot current model
     *
     * Save all model parameters currently trained, this will be used for `Resume`.
     * A model file will be save at `../model/jda_tmp_{%time%}_{stage}.model`,
     * `%time%` is the saving time point format `%Y%m%D-%H%M%S` like `20151011-103625`
     * `stage` is current stage range in [1..T]
     */
    void Snapshot();
    /**
     * Resume the Training Status
     * :input stage:        which stage to start from, range in [1, c.T)
     * :input fd:           file discriptor of the model file
     *
     * Resume the Training Status from a Snapshot model file. We will load the model
     * parameters and check if the global parameters are the same as `Config`, if not,
     * the program will be terminateed. After the parameters loaded, Positive Samples
     * will be processed to generate the Positive DataSet, the Negative DataSet will
     * be generated by hard negative mining.
     */
    void ResumeFrom(int stage, FILE* fd);
    /**
     * Write parameters to a binary file
     * :input fd:           file discriptor of the model file
     * :input stage:        stage range in [0, c.T)
     *
     * Write the model parameters from stage 0 to stage `stage`,
     * the default stage is the last one.
     */
    void SerializeTo(FILE* fd, int stage = -1);
    /**
     * Read parameters from a binary file
     * :input fd:           file discriptor of the model file
     * :input stage:        stage range in [0, c.T)
     *
     * Read model parameters from stage 0 to stage `stage`,
     * the default stage is the last one.
     */
    void SerializeFrom(FILE* fd, int stage = -1);

public:
    /**
     * Validate a region whether a face or not
     * :input img:      image
     * :output score:   classification score of this image
     * :output shape:   shape on this image
     * :return:         whether a face or not
     *
     * In training state, we use this function for hard negative mining based on
     * the training status. In testing state, we just go through all carts to get
     * a face score for this region. The training status is based on `current_stage_idx`
     * and `current_cart_idx`.
     */
    bool Validate(const cv::Mat& image, double& score, cv::Mat_<double>& shape) const;

public:
    int T; // number of stages
    cv::Mat_<double> mean_shape; // mean shape of positive training data

    std::vector<BoostCart> btcarts;

    // training status
    int current_stage_idx; // range in [0, c.T)
    int current_cart_idx; // range in [0, c.K)
};

} // namespace jda

#endif // CASCADOR_HPP_
